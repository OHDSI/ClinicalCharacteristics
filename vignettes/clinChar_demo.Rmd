---
title: "How to use ClinicalCharacteristics"
author:
  - Martin Lavallee
  - Katy Sadowski
  - Ajit Londhe
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{How to use ClinicalCharacteristics}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Introduction

When conducting real-world evidence (RWE) studies, analysts often need to populate table-shells defined by clinical colleagues. In principle, these table-shells should be simple to generate, as they consist primarily of counts and percentages for categorical variables and summary statistics for continuous variables. Surprisingly, this task proves to be non-trivial when using the available OHDSI tools. The best available tool for characterization is `FeatureExtraction` which is a tool designed to extract as many clinical features as possible to use as covariates for high-dimensional modelling. While helpful for modelling, populating table-shells is awkward because it pulls all concepts from a domain and performs characterization at the individual concept level. One could also use the web application ATLAS to characterize, however, it does not fit programmatic driven pipelines. With some of these gaps in mind, we designed a new OHDSI tool titled `ClinicalCharacteristics` which is a table shell approach to OMOP characterization. 

# Features

A characterization requires the identification of a clinical event during a specified window of time relative to the index date of the cohort of interest. For example if we wish to look at baseline characteristics, we anchor our enumeration on the date at which the person enters the cohort and consider a window of time as baseline (say -365 days to -1 days relative to index). There are a few assumptions we need to make from this construction: a) what type of event are we looking for, b) when are we looking, relative to index, and must it be during observed time and c) how do we want to summarize this information. 

## Data Types

`ClinicalCharacteristics` can summarize the following types of OHDSI objects:

- **Demographics**: information rooted in the person table such as age, gender, race, and ethnicity.
- **Concept Sets**: groupings of concepts in a single domain, applying hierarchical logic to identify large lists of clinical concepts. For example a Type 2 Diabetes concept set would include the high-level concept and its descendants.
- **Concept Set Groups**: groups of concepts across multiple domains. Sometimes concepts for an occurrence do not occur in one domain (i.e conditions, drugs, procedures) but in multiple like smoking status; occurs in observation, procedure and condition tables. This item unifies them as a single entity
- **Cohorts**: identification of clinical event across a set of persons over an era of time bracketed by an entry and exit event. Cohorts apply the occurrence of an event accounting for attrition based on inclusion/exclusion criteria. 
- **Source Codes**: [Future Addition] a list of non-standard codes under a single vocabulary to identify events. It is not recommended to use this type of object because it does not leverage the advantages of semantic standardization
- **Other**: [Future Addition] Sometimes clinically relevant events don't fall into the these categories and require special consturctions to query in the CDM. Items such as lab measurements, locations and episodes. 


## Value Types

Beyond types of domains to summarize, there are different ways of performing an aggregation of information. `ClinicalCharacteristics` can create tables based on these value types:

- **Presence**: an event is either observed or not observed for a patient given a time window. With this statistic type we report a categorical value as n and percent.
- **ContinuousDistribution**: how many times is an event observed during a period of time. With this statistic type we report as a continuous value using mean, standard deviation and default order statistics
- **Breaks**: sometimes we want to convert a continuous value into a categorical grouping. For example persons taking 1, 2, 3, or 4+ medications during a period of time. We apply breaks to categorize counts and report as a categorical value with n and percent
- **Score**: [Future Addition] the inverse of breaks, we may want to turn a categorical grouping into a continuous value. For example we wish to apply a weight to the presence of an event and the summarize a collection of scores per patient. 

## Observed Time

Another consideration is whether to summarize occurrence based on any time or observed time. When we define a time window for characterization this does not consider whether the persons where under continuous observation. To add this feature in we need to specify to count only persons who were actively followed during the interval in both the numerator and denominator. `ClinicalCharacteristics` specifies if we enumerate at **any** time (naively apply the time window) or **observed** (apply the time window in the context of observed time). It is recommended to use **any** time for most characterization, as it is the simplest to interpret. 


# Setup

## Execution Settings

As do all OHDSI tools we need to setup the database credentials of the dbms hosting the OMOP data we wish to use with `ClinicalCharacteristics`. We use the HADES package [`DatabaseConnector`](https://ohdsi.github.io/DatabaseConnector/) to create a `connectionDetails` object that can be used to establish a database connection. Below we provide an example of setting up connection details, where users can find more references from the `DatabaseConnector` documentation. 

```{r eval=FALSE}
# set a environment variable defining the jar folder path
Sys.setenv("DATABASECONNECTOR_JAR_FOLDER" = "c:/temp/jdbcDrivers")

# download the jdbc driver
DatabaseConnector::downloadJdbcDrivers("postgresql")

connectionDetails <- DatabaseConnector::createConnectionDetails(
  dbms = "postgresql",
  user = "joe",
  password = "secret",
  connectionString = "jdbc:postgresql://localhost:5432/postgres"
)

# test the connection
con <- DatabaseConnector::connect(connectionDetails)
DatabaseConnector::disconnect(con)

```


Something we are introducing within the `ClinicalCharacteristics` package is a class called `ExecutionSettings`. This object maintains all the settings needed to execute a query on your dbms. Key parameters include:

- **cdmDatabaseSchema**: a read only schema where the OMOP cdm is located
- **workDatabaseSchema**: a read/write schema where you will conduct work; effectively the location of the cohort table
- **tempEmulationSchema**: a read/write schema to store temp tables. Note this is only necessary for dbms' like snowflake and oracle that handle temp tables differently than other dialects
- **targetCohortTable**: the name of the cohort table where your target cohorts exist
- **cdmSourceName**: a label for the cdm in use


In `ClinicalCharacteristics` we can set up our execution settings object as follows:

```{r eval=FALSE}
executionSettings <- createExecutionSettings(
  connectionDetails = connectionDetails,
  cdmDatabaseSchema = "omop_schema",
  workDatabaseSchema = "my_schema",
  tempEmulationSchema = "my_schema",
  targetCohortTable = "my_cohorts",
  cdmSourceName = "my_omop"
)
```

The convenience of this object is that it serves as a container to pass parameters to steps the execute sql. Note users also do not need to worry about opening and closing connections when using these tools. 

To replace parameters in the executionSettings object is done through simple assignment:

```{r eval=FALSE}
executionSettings$cdmSourceName <- "my_other_omop"
executionSettings$workDatabaseSchema <- "my_other_schema"
```


## Cohorts

`ClinicalCharacteristics` works under the assumption that cohorts have already been instantiated in the cohort table. For new OHDSI users, please review the `CohortGenerator` [package](https://ohdsi.github.io/CohortGenerator/articles/GeneratingCohorts.html) on how to instantiate cohorts in the cohort table. 


## Concept Sets

Our key distinguishing feature to the `FeatureExtraction` package is the ability to characterize using Concept Sets as opposed to individual concept ids. There are two ways to import concept sets into the `ClinicalCharacteristics` work flow: a) import from json or b) create on the fly. Both methods apply the R package [`Capr`](https://github.com/OHDSI/Capr). 

### Import from Json

Users can export a concept set definition json from ATLAS and save as a file with json extension. To import the concept set into R as an object do as follows:

```{r eval=FALSE}
conceptSetFile <- here::here("my_concept_set.json")
cs1 <- Capr::readConceptSet(
  path = conceptSetFile,
  name = "My Concept Set"
)
```

Recommend using this method if you have complex concept sets. 

### Create on the Fly

Also using `Capr` one can create a simple concept set using the standard concept id of interest.

```{r}
cs2 <- Capr::cs(Capr::descendants(201826), name = "t2d")
```

This function creates a concept set class in Capr. We take the standard concept for type 2 diabetes and include its descendants to make a concept set. Recommend this method when building simple concept sets. 

# Using ClinicalCharacteristics

Now that we have setup the requirements for `ClinicalCharacteristics` we can begin to use the program to develop table shells. The goal is to populate a `TableShell` class object with the details of how you want to populate your table. Each element of the table is called a line item. The line item uniquely summarizes events with a particular statistic type at a specified time window. For example, if we want to characterize ckd we need to specify the line item:

```{r eval=FALSE}
ckd_cs <- Capr::cs(Capr::descendants(46271022), name = "ckd")
createConceptSetLineItem(
  sectionLabel = "CKD: Baseline",
  domain = "condition_occurrence",
  statistic = anyPresenceStat(),
  conceptSet = ckd_cs,
  timeInterval = tw1
)
```

The section label specifies how we want to identify the line item within the table as a section. The domain must specify which domain table in the cdm we should check for events. Since CKD is condition we want to check the *condition_occurrence* table. If we were characterizing drugs we would check the *drug_exposure* table. Review the [OMOP CDM](https://ohdsi.github.io/CommonDataModel/cdm54.html#Current_Support_for_CDM_v54) to become familiar with the different types of domains. The statistic determines how to summarize the event; here are examples:

- `PresenceStat`: determine who had an occurrence of an event during an interval
- `CountCtsStat`: determine the continuous distribution of an event during an interval
- `CountBreaksStat`: convert the count to breaks of an event during an interval
- `TimeToFirstCtsStat`: determine the continuous distribution of the time to the occurrence of the first event
- `TimeToFirstBreaksStat`: convert the time to the first event into a break of values

To distinguish between **any** and **observed** add the keyword as a prefix (i.e. `anyPresenceStat()` or `observedPresenceStat()`). 

## Basic Example

Let's use the following details for an example table shell, assuming a cohort for type 2 diabetes has been created:

- male gender
- age as continuous
- presence of condition ckd -365d to -1d prior to index
- presence of condition t2d -365d to -1d prior to index
- presence of drug sglt2 0d to 90d post index

```{r setup, eval=FALSE}
library(ClinicalCharacteristics)

# Define Execution Settings
executionSettings <- createExecutionSettings(
  connectionDetails = connectionDetails,
  cdmDatabaseSchema = "omop_schema",
  workDatabaseSchema = "my_schema",
  tempEmulationSchema = "my_schema",
  targetCohortTable = "my_cohorts",
  cdmSourceName = "my_omop"
)

# create each concept set
ckd_cs <- Capr::cs(Capr::descendants(46271022), name = "ckd")
hf_cs <- Capr::cs(Capr::descendants(316139), name = "hf")
sglt2_cs <- Capr::cs(Capr::descendants(1123627), name = "sglt2")

# make each time window
tw1 <- timeInterval(lb = -365, rb = -1)
tw2 <- timeInterval(lb = 0, rb = 90)

# define table shell
ts <- creatTableShell(
  name = "Demo 1",
  targetCohorts = list(
    createCohortInfo(id = 1, name = "Type 2 Diabetes")
  ),
  lineItems = lineItems(
    createDemographicLineItem(maleGender()),
    createDemographicLineItem(ageChar()),
    createConceptSetLineItem(
      sectionLabel = "CKD: Baseline",
      domain = "condition_occurrence",
      statistic = anyPresenceStat(),
      conceptSet = ckd_cs,
      timeInterval = tw1
    ),
    createConceptSetLineItem(
      sectionLabel = "HF: Baseline",
      domain = "condition_occurrence",
      statistic = anyPresenceStat(),
      conceptSet = hf_cs,
      timeInterval = tw1
    ),
    createConceptSetLineItem(
      sectionLabel = "SGLT2: Post Index",
      domain = "drug_exposure",
      statistic = anyPresenceStat(),
      conceptSet = sglt2_cs,
      timeInterval = tw2
    )
  )
)

res <- generateTableShell(tableShell, executionSettings)
res$categorical
res$continuous

```

`ClinicalCharacteristics` treats every input to the table as a line item. So to populate th
